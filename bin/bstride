#!/usr/bin/env ruby
# Copyright UNLICENSE https://github.com/johslarsen/binop/blob/master/bin/bstride
require 'forwardable'
require 'optparse'

def parse_range(r)
  case r
  when /^(-?(0[xX])?\h+)$/
    from = Integer($~[1])
    from..from
  when /^(-?(0[xX])?\h+)?\.\.(-?(0[xX])?\h+)?$/
    from = Integer($~[1] || 0)
    to = Integer($~[3] || -1)
    from..to
  else
    raise "Not a range #{r.inspect}"
  end
end

UnpackedRange = Struct.new :range, :directive, :format
VlenRecord = Struct.new :range, :directive, :extra_bytes

$opts = {}
OptionParser.new do |o|
  o.banner = "Usage: #{$0} [options] [FILE]..."
  NonNegative = Struct.new :n
  o.accept NonNegative do |str|
    raise "Cannot be negative: #{str.inspect}" if (n = Integer(str)) < 0
    n
  end

  $opts[:actions] = []
  o.separator "Actions (executed in order specified)"
  o.on "-f", '--fields N,"N..M",...', Array,
      "Copy bytes at indexes / in ranges to output" do |fields|
    $opts[:actions].concat(fields.map{|f|parse_range(f)})
  end
  o.on "-p", "--pack HEX[,HEX]...[:DIRECTIVE-=C*]",
      "Write a packed HEX literal to the output",
      "See `ri Array.pack` for how to specify DIRECTIVE" do |literals_directive|
    l, d = literals_directive.split ':'
    $opts[:actions] << l.split(',').map{|n|Integer(n, 16)}.pack(d||"C*")
  end
  o.on "-u", '--unpack N,"N..M",...[:DIRECTIVE-=C*][/FORMAT= %02x]',
      "Write unpacked ranges of bytes to the output",
      "See `ri String.unpack` for how to specify DIRECTIVE" do |fields_directive_format|
    fields_directive, format = fields_directive_format.split("/")
    fields, d = fields_directive.split ':'
    $opts[:actions].concat(fields.split(',').map do |f|
      UnpackedRange.new(parse_range(f), d||"C*", format||" %02x")
    end)
  end
  o.on "-t", "--text UTF-8", "Write the UTF-8 literal to the output" do |s|
    $opts[:actions] << s
  end

  o.separator "Record processing"
  $opts[:width] = 16
  o.on "-w", "--width BYTES", NonNegative, "Fixed sized record length. Default: #{$opts[:width]}" do |w|
    $opts[:width] = w
  end
  o.on "-l", "--length N..M[:DIRECTIVE-=S>][+BYTES]",
      "Varibale length record unpacked from N..Mth bytes + BYTES.",
      "Write unpacked ranges of bytes to the output" do |range_directive_bytes|
    range_directive, bytes = range_directive_bytes.split '+'
    range, directive = range_directive.split ':'
    $opts[:width] = VlenRecord.new(parse_range(range), directive || "S>", Integer(bytes || 0))
  end

  $opts[:skip] = 0
  o.on "-s", "--skip BYTES", NonNegative, "Skip the first BYTES" do |offset|
    $opts[:skip] = offset
  end
  o.on "-c", "--count COUNT", NonNegative, "Only process COUNT records" do |count|
    $opts[:count] = count
  end
end.permute!

class SeekablePipe
  extend Forwardable
  def_delegators :@file, :closed?, :eof?

  def initialize(file)
    @file = file
    @buffer = "" # grows as needed
    @offset = nil
  end

  def read(nbyte)
    @buffer = @file.read nbyte, @buffer
    @offset += nbyte if @offset
    @buffer
  end

  def seek(bof_offset)
    @offset ? skip_to(bof_offset) : @file.seek(bof_offset)
  rescue Errno::ESPIPE
    @offset ||= 0
    skip_to bof_offset
  end

  def read_range(range, width, offset=0)
    from = range.first < 0 ? width+range.first : range.first
    length = (range.last < 0 ? width+range.last : range.last) - from + 1
    return "" if length < 0 || width && from >= width
    length = width - from if width && from + length > width
    return nil unless seek(offset + from)
    read(length)
  end

  def self.stdin_or_each(fnames)
    yield self.new($stdin) if ARGV.empty?
    fnames.each do |fname|
      if fname == '-'
        yield self.new $stdin
      else
        File.open(fname) {|f| yield self.new(f)}
      end
    end
  end

  private def skip_to(bof_offset)
    raise "Cannot seek backward in pipe" if bof_offset < @offset
    @offset, before_seek = bof_offset, @offset
    buffer_if_not_expanding = bof_offset < @buffer.length ? @buffer : nil
    @file.read(bof_offset - before_seek, buffer_if_not_expanding)
  end
end

SeekablePipe.stdin_or_each ARGV do |file|
  offset = $opts[:skip]
  ($opts[:count] ? 0...$opts[:count] : 0.step).each do |i|
    break if file.closed? || file.eof?
    width = $opts[:width]
    if width.is_a? VlenRecord
      break unless (bytes = file.read_range(width.range, nil, offset))
      width = bytes.unpack(width.directive).first + width.extra_bytes
    end
    $opts[:actions].each do |action|
      case action
      when String
        $stdout.write action
      when Range
        break unless (bytes = file.read_range action, width, offset)
        $stdout.write bytes
      when UnpackedRange
        break unless (bytes = file.read_range action.range, width, offset)
        $stdout.write bytes.unpack(action.directive).map{|s| action.format % [s]}.join
      end
    end
    offset += width
  end
end

#!/usr/bin/env ruby
# Copyright UNLICENSE https://github.com/johslarsen/binop/blob/master/bin/bstride
require 'optparse'

def parse_range(r)
  case r
  when /^(-?(0[xX])?\h+)$/
    from = Integer($~[1])
    from..from
  when /^(-?(0[xX])?\h+)?\.\.(-?(0[xX])?\h+)?$/
    from = Integer($~[1] || 0)
    to = Integer($~[3] || -1)
    from..to
  else
    raise "Not a range #{r.inspect}"
  end
end

UnpackedRange = Struct.new :range, :directive, :format
VlenRecord = Struct.new :range, :directive, :extra_bytes

$opts = {}
OptionParser.new do |o|
  o.banner = "Usage: #{$0} [options] [FILE]..."
  NonNegative = Struct.new :n
  o.accept NonNegative do |str|
    raise "Cannot be negative: #{str.inspect}" if (n = Integer(str)) < 0
    n
  end

  $opts[:actions] = []
  o.separator "Actions (executed in order specified)"
  o.on "-f", '--fields N,"N..M",...', Array,
      "Copy bytes at indexes / in ranges to output" do |fields|
    $opts[:actions].concat(fields.map{|f|parse_range(f)})
  end
  o.on "-p", "--pack HEX[,HEX]...[:DIRECTIVE-=C*]",
      "Write a packed HEX literal to the output",
      "See `ri Array.pack` for how to specify DIRECTIVE" do |literals_directive|
    l, d = literals_directive.split ':'
    $opts[:actions] << l.split(',').map{|n|Integer(n, 16)}.pack(d||"C*")
  end
  o.on "-u", '--unpack N,"N..M",...[:DIRECTIVE-=C*][/FORMAT= %02x]',
      "Write unpacked ranges of bytes to the output",
      "See `ri String.unpack` for how to specify DIRECTIVE" do |fields_directive_format|
    fields_directive, format = fields_directive_format.split("/")
    fields, d = fields_directive.split ':'
    $opts[:actions].concat(fields.split(',').map do |f|
      UnpackedRange.new(parse_range(f), d||"C*", format||" %02x")
    end)
  end
  o.on "-t", "--text UTF-8", "Write the UTF-8 literal to the output" do |s|
    $opts[:actions] << s
  end

  o.separator "Record processing"
  $opts[:width] = 16
  o.on "-w", "--width BYTES", NonNegative, "Fixed sized record length. Default: #{$opts[:width]}" do |w|
    $opts[:width] = w
  end
  o.on "-l", "--length N..M[:DIRECTIVE-=S>][+BYTES]",
      "Varibale length record unpacked from N..Mth bytes + BYTES.",
      "Write unpacked ranges of bytes to the output" do |range_directive_bytes|
    range_directive, bytes = range_directive_bytes.split '+'
    range, directive = range_directive.split ':'
    $opts[:width] = VlenRecord.new(parse_range(range), directive || "S>", Integer(bytes || 0))
  end

  $opts[:skip] = 0
  o.on "-s", "--skip BYTES", NonNegative, "Skip the first BYTES" do |offset|
    $opts[:skip] = offset
  end
  o.on "-c", "--count COUNT", NonNegative, "Only process COUNT records" do |count|
    $opts[:count] = count
  end
end.permute!

class SeekablePipe
  def initialize(file)
    @file = file
    @buffer = String.new encoding: Encoding::ASCII_8BIT # grows as needed
    @pipe_buffer = nil
  end

  def pread(maxlen, offset)
    @pipe_buffer ? pipe_read(maxlen, offset) : @file.pread(maxlen, offset, @buffer)
  rescue EOFError
    return nil # act like read
  rescue Errno::ESPIPE
    @pipe_buffer = String.new encoding: Encoding::ASCII_8BIT
    @pb_offset = 0
    retry
  end

  def read_range(range, width, offset=0)
    from = range.first < 0 ? width+range.first : range.first
    length = (range.last < 0 ? width+range.last : range.last) - from + 1
    return "" if length < 0 || width && from >= width
    length = width - from if width && from + length > width
    return pread length, offset + from
  end

  def self.stdin_or_each(fnames)
    yield self.new($stdin) if ARGV.empty?
    fnames.each do |fname|
      if fname == '-'
        yield self.new $stdin
      else
        File.open(fname) {|f| yield self.new(f)}
      end
    end
  end

  def clear_buffered
    if @pipe_buffer
      @pb_offset += @pipe_buffer.size
      @pipe_buffer.clear
    end
  end

  private def pipe_read(maxlen, offset)
    raise "Cannot seek earlier than start of pipe buffer" if offset < @pb_offset
    from = offset - @pb_offset
    to = from + maxlen
    nread = to - @pipe_buffer.size
    if nread > 0
      return @pipe_buffer[from..-1] unless @file.read nread, @buffer
      @pipe_buffer << @buffer
    end
    @pipe_buffer[from...to]
  end
end

SeekablePipe.stdin_or_each ARGV do |file|
  offset = $opts[:skip]
  ($opts[:count] ? 0...$opts[:count] : 0.step).each do |i|
    file.clear_buffered
    width = $opts[:width]
    if width.is_a? VlenRecord
      break unless (bytes = file.read_range(width.range, nil, offset))
      width = bytes.unpack(width.directive).first + width.extra_bytes
    end

    break unless $opts[:actions].each do |action|
      case action
      when String
        $stdout.write action
      when Range
        break unless (bytes = file.read_range action, width, offset)
        $stdout.write bytes
      when UnpackedRange
        break unless (bytes = file.read_range action.range, width, offset)
        $stdout.write bytes.unpack(action.directive).map{|s| action.format % [s]}.join
      end
    end
    offset += width
  end
end
